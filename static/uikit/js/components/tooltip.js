/*! For license information please see tooltip.js.LICENSE.txt */
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i(require("uikit-util")):"function"==typeof define&&define.amd?define("uikittooltip",["uikit-util"],i):(t="undefined"!=typeof globalThis?globalThis:t||self).UIkitTooltip=i(t.UIkit.util)}(this,(function(t){"use strict";function i(i,e=[]){try{return i?t.startsWith(i,"{")?JSON.parse(i):e.length&&!t.includes(i,":")?{[e[0]]:i}:i.split(";").reduce(((i,e)=>{const[s,o]=e.split(/:(.*)/);return s&&!t.isUndefined(o)&&(i[s.trim()]=o.trim()),i}),{}):{}}catch(t){return{}}}t.memoize(((i,e)=>{const s=Object.keys(e),o=s.concat(i).map((i=>[t.hyphenate(i),`data-${t.hyphenate(i)}`])).flat();return{attributes:s,filter:o}}));let e=1;function s(t,i=null){return(null==i?void 0:i.id)||`${t.$options.id}-${e++}`}var o={props:{container:Boolean},data:{container:!0},computed:{container({container:i}){return!0===i&&this.$container||i&&t.$(i)}}},n={props:{pos:String,offset:null,flip:Boolean,shift:Boolean,inset:Boolean},data:{pos:"bottom-"+(t.isRtl?"right":"left"),offset:!1,flip:!0,shift:!0,inset:!1},connected(){this.pos=this.$props.pos.split("-").concat("center").slice(0,2),[this.dir,this.align]=this.pos,this.axis=t.includes(["top","bottom"],this.dir)?"y":"x"},methods:{positionAt(i,e,s){let o=[this.getPositionOffset(i),this.getShiftOffset(i)];const n=[this.flip&&"flip",this.shift&&"shift"],r={element:[this.inset?this.dir:t.flipPosition(this.dir),this.align],target:[this.dir,this.align]};if("y"===this.axis){for(const t in r)r[t].reverse();o.reverse(),n.reverse()}const l=function(i){const e=t.scrollParent(i),{scrollTop:s}=e;return()=>{s!==e.scrollTop&&(e.scrollTop=s)}}(i),a=t.dimensions(i);t.css(i,{top:-a.height,left:-a.width}),t.positionAt(i,e,{attach:r,offset:o,boundary:s,placement:n,viewportOffset:this.getViewportOffset(i)}),l()},getPositionOffset(i=this.$el){return t.toPx(!1===this.offset?t.css(i,"--uk-position-offset"):this.offset,"x"===this.axis?"width":"height",i)*(t.includes(["left","top"],this.dir)?-1:1)*(this.inset?-1:1)},getShiftOffset(i=this.$el){return"center"===this.align?0:t.toPx(t.css(i,"--uk-position-shift-offset"),"y"===this.axis?"width":"height",i)*(t.includes(["left","top"],this.align)?1:-1)},getViewportOffset:i=>t.toPx(t.css(i,"--uk-position-viewport-offset"))}},r={props:{cls:Boolean,animation:"list",duration:Number,velocity:Number,origin:String,transition:String},data:{cls:!1,animation:[!1],duration:200,velocity:.2,origin:!1,transition:"ease",clsEnter:"uk-togglable-enter",clsLeave:"uk-togglable-leave"},computed:{hasAnimation:({animation:t})=>!!t[0],hasTransition:({animation:i})=>["slide","reveal"].some((e=>t.startsWith(i[0],e)))},methods:{async toggleElement(i,e,s){try{return await Promise.all(t.toNodes(i).map((i=>{const o=t.isBoolean(e)?e:!this.isToggled(i);if(!t.trigger(i,"before"+(o?"show":"hide"),[this]))return Promise.reject();const n=(t.isFunction(s)?s:!1!==s&&this.hasAnimation?this.hasTransition?a:h:l)(i,o,this),r=o?this.clsEnter:this.clsLeave;t.addClass(i,r),t.trigger(i,o?"show":"hide",[this]);const c=()=>{t.removeClass(i,r),t.trigger(i,o?"shown":"hidden",[this])};return n?n.then(c,(()=>(t.removeClass(i,r),Promise.reject()))):c()}))),!0}catch(t){return!1}},isToggled(i=this.$el){return i=t.toNode(i),!!t.hasClass(i,this.clsEnter)||!t.hasClass(i,this.clsLeave)&&(this.cls?t.hasClass(i,this.cls.split(" ")[0]):t.isVisible(i))},_toggle(i,e){if(!i)return;let s;e=Boolean(e),this.cls?(s=t.includes(this.cls," ")||e!==t.hasClass(i,this.cls),s&&t.toggleClass(i,this.cls,t.includes(this.cls," ")?void 0:e)):(s=e===i.hidden,s&&(i.hidden=!e)),t.$$("[autofocus]",i).some((i=>t.isVisible(i)?i.focus()||!0:i.blur())),s&&t.trigger(i,"toggled",[e,this])}}};function l(i,e,{_toggle:s}){return t.Animation.cancel(i),t.Transition.cancel(i),s(i,e)}async function a(i,e,{animation:s,duration:o,velocity:n,transition:r,_toggle:l}){var a;const[h="reveal",c="top"]=(null==(a=s[0])?void 0:a.split("-"))||[],d=[["left","right"],["top","bottom"]],f=d[t.includes(d[0],c)?0:1],u=f[1]===c,p=["width","height"][d.indexOf(f)],g=`margin-${f[0]}`,m=`margin-${c}`;let w=t.dimensions(i)[p];const v=t.Transition.inProgress(i);await t.Transition.cancel(i),e&&l(i,!0);const b=Object.fromEntries(["padding","border","width","height","minWidth","minHeight","overflowY","overflowX",g,m].map((t=>[t,i.style[t]]))),$=t.dimensions(i),y=t.toFloat(t.css(i,g)),T=t.toFloat(t.css(i,m)),k=$[p]+T;v||e||(w+=T);const[x]=t.wrapInner(i,"<div>");t.css(x,{boxSizing:"border-box",height:$.height,width:$.width,...t.css(i,["overflow","padding","borderTop","borderRight","borderBottom","borderLeft","borderImage",m])}),t.css(i,{padding:0,border:0,minWidth:0,minHeight:0,[m]:0,width:$.width,height:$.height,overflow:"hidden",[p]:w});const P=w/k;o=(n*k+o)*(e?1-P:P);const O={[p]:e?k:0};u&&(t.css(i,g,k-w+y),O[g]=e?y:k+y),!u^"reveal"===h&&(t.css(x,g,-k+w),t.Transition.start(x,{[g]:e?0:-k},o,r));try{await t.Transition.start(i,O,o,r)}finally{t.css(i,b),t.unwrap(x.firstChild),e||l(i,!1)}}function h(i,e,s){const{animation:o,duration:n,_toggle:r}=s;return e?(r(i,!0),t.Animation.in(i,o[0],n,s.origin)):t.Animation.out(i,o[1]||o[0],n,s.origin).then((()=>r(i,!1)))}var c={mixins:[o,r,n],data:{pos:"top",animation:["uk-animation-scale-up"],duration:100,cls:"uk-active"},connected(){var i;i=this.$el,t.isFocusable(i)||t.attr(i,"tabindex","0")},disconnected(){this.hide()},methods:{show(){if(this.isToggled(this.tooltip||null))return;const{delay:e=0,title:o}=function(e){const{el:s,id:o,data:n}=e;return["delay","title"].reduce(((i,e)=>({[e]:t.data(s,e),...i})),{...i(t.data(s,o),["title"]),...n})}(this.$options);if(!o)return;const n=t.attr(this.$el,"title"),r=t.on(this.$el,["blur",t.pointerLeave],(i=>!t.isTouch(i)&&this.hide()));this.reset=()=>{t.attr(this.$el,{title:n,"aria-describedby":null}),r()};const l=s(this);t.attr(this.$el,{title:null,"aria-describedby":l}),clearTimeout(this.showTimer),this.showTimer=setTimeout((()=>this._show(o,l)),e)},async hide(){var i;t.matches(this.$el,"input:focus")||(clearTimeout(this.showTimer),this.isToggled(this.tooltip||null)&&await this.toggleElement(this.tooltip,!1,!1),null==(i=this.reset)||i.call(this),t.remove(this.tooltip),this.tooltip=null)},async _show(i,e){this.tooltip=t.append(this.container,`<div id="${e}" class="uk-${this.$options.name}" role="tooltip"> <div class="uk-${this.$options.name}-inner">${i}</div> </div>`),t.on(this.tooltip,"toggled",((i,e)=>{if(!e)return;const s=()=>this.positionAt(this.tooltip,this.$el);s();const[o,n]=function(i,e,[s,o]){const n=t.offset(i),r=t.offset(e),l=[["left","right"],["top","bottom"]];for(const t of l){if(n[t[0]]>=r[t[1]]){s=t[1];break}if(n[t[1]]<=r[t[0]]){s=t[0];break}}return[s,(t.includes(l[0],s)?l[1]:l[0]).find((t=>n[t]===r[t]))||"center"]}(this.tooltip,this.$el,this.pos);this.origin="y"===this.axis?`${t.flipPosition(o)}-${n}`:`${n}-${t.flipPosition(o)}`;const r=[t.once(document,`keydown ${t.pointerDown}`,this.hide,!1,(i=>i.type===t.pointerDown&&!this.$el.contains(i.target)||"keydown"===i.type&&27===i.keyCode)),t.on([document,...t.overflowParents(this.$el)],"scroll",s,{passive:!0})];t.once(this.tooltip,"hide",(()=>r.forEach((t=>t()))),{self:!0})})),await this.toggleElement(this.tooltip,!0)||this.hide()}},events:{[`focus ${t.pointerEnter} ${t.pointerDown}`](i){t.isTouch(i)&&i.type!==t.pointerDown||this.show()}}};return"undefined"!=typeof window&&window.UIkit&&window.UIkit.component("tooltip",c),c}));